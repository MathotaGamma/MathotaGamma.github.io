<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Cubiro | NeoTopazm</title>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.141.0/build/three.module.js"
        }
      }
    </script>
    <style>
      html, body {
        width: 100%;
        height: 100%;
        padding: 0;
        margin: 0;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        overflow: hidden;
        touch-action: none;
      }
      
      header {
        box-sizing: border-box;
        position: absolute;
        display: flex;
        align-items: center;
        padding: 10px;
        gap: 15px;
        top: 0px;
        left: 0px;
        width: 100%;
        height: 40px;
        background: grey;
        color: white;
      }
      
      header .button {
        padding: 2px;
        border: 1px solid white;
        border-radius: 2px;
      }
      
      #text {
        position: absolute;
        top: 40px;
        left: 0px;
        height: 40px;
        color: white;
        z-index: 999;
        font-family: monospace;
      }
      
      #overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        z-index: 1000;
      }
      
      #message {
        background: white;
        color: black;
        padding: 20px 40px;
        font-size: 24px;
        border-radius: 10px;
        margin-bottom: 20px;
        text-align: center;
      }
      
      .button-group {
        display: flex;
        gap: 20px;
      }
      
      .overlay-button {
        padding: 10px 20px;
        font-size: 18px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }
      
      canvas {
        position: absolute;
        top: 40px;
        left: 0px;
      }
    </style>
  </head>
  <body>
    <header>
      <div>3D Athletic</div>
      <div class="button" id="retry">Retry</div>
    </header>
    <div id="overlay" style="display:none;">
      <div id="message"></div>
      <div class="button-group" id="buttonGroup"></div>
    </div>
    <div id="text"></div>
    <canvas id="canvas"></canvas>
    
    
    <script type="module">
      import * as THREE from "three";
      const headerHeight = 40;
      
      const header = document.getElementsByTagName("header")[0];
      
      const overlay = document.getElementById("overlay");
      const messageDiv = document.getElementById("message");
      const buttonGroup = document.getElementById("buttonGroup");

      /*
       * テロップを表示する
       * @param {string} text - 表示するテキスト
       * @param {Object} options - オプション
       *   mode: "ok" | "yesno"  ボタンの種類
       *   onOk: function        OK押下時の処理
       *   onYes: function       YES押下時の処理
       *   onNo: function        NO押下時の処理
       */
      function showOverlay(text, options = {}) {
        messageDiv.innerHTML = text.replace(/\n/g, "<br>");
        buttonGroup.innerHTML = "";

        if (options.mode === "yesno") {
          const yesBtn = document.createElement("button");
          yesBtn.textContent = "YES";
          yesBtn.className = "overlay-button";
          yesBtn.onclick = () => {
            overlay.style.display = "none";
            if (options.onYes) options.onYes();
          };

          const noBtn = document.createElement("button");
          noBtn.textContent = "NO";
          noBtn.className = "overlay-button";
          noBtn.onclick = () => {
            overlay.style.display = "none";
            if (options.onNo) options.onNo();
          };

          buttonGroup.appendChild(yesBtn);
          buttonGroup.appendChild(noBtn);

        } else {
          const okBtn = document.createElement("button");
          okBtn.textContent = "OK";
          okBtn.className = "overlay-button";
          okBtn.onclick = () => {
            overlay.style.display = "none";
            if (options.onOk) options.onOk();
          };
          buttonGroup.appendChild(okBtn);
        }

        overlay.style.display = "flex";
      }

      showOverlay("Cubiroへようこそ！\nチュートリアルを行いますか？", {mode: "yesno", onYes: () => {stage = 0; init();setTimeout(tutorial, 1000);}, onNo: () => {stage = 1; init();}})
      
      // 時間待ち（ms単位）
      function wait(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      // 条件待ち（関数がtrueを返すまで待つ）
      function waitUntil(conditionFn, interval = 100) {
        return new Promise(resolve => {
          const check = () => {
            if (conditionFn()) {
              resolve();
            } else {
              setTimeout(check, interval);
            }
          };
          check();
        });
      }
      
      async function tutorial() {
        await new Promise(resolve => {
          showOverlay("画面左側をスワイプすると視点を変更できます。", {
            onOk: resolve
          });
        });
        
        await wait(3000);
        
        await new Promise(resolve => {
          showOverlay("次はCubeを転がしてみましょう。\nCubeの移動は画面右側をスワイプします。", {
            onOk: resolve
          });
        });
        
        await waitUntil(() => me.rolling === true);
        
        await new Promise(resolve => {
          showOverlay("Cubeの側面や下面に張り付いて移動することができます！\nしかし、頭上にブロックがある(上と下に挟まれている)場合、移動ができません。", {
            onOk: resolve
          });
        });
        
        await wait(3000);
        
        await new Promise(resolve => {
          showOverlay("動けなくなった場合や、やり直したい時は\n左上の「Retry」ボタンを押してください。", {
            onOk: resolve
          });
        });
        
        await wait(3000);
        
        await new Promise(resolve => {
          showOverlay("他にも、赤いブロックを触れると死亡判定となります。\n水色のブロックは滑りやすいです。\nこれらを踏まえて、ゴールの黄色いブロックを目指しましょう！", {
            onOk: resolve
          });
        });
        
      }
      
      const setting = {
        shadow: true,
        shadowMapSize: 4096,
        cameraSensitivity: {
          yaw: 1,
          pitch: 1
        },
        deadLineY: -5,
      }
      
      let w = innerWidth;
      let h = innerHeight - headerHeight;
      
      const textDiv = document.getElementById("text");
      
      const canvas = document.getElementById("canvas");
      canvas.width = w;
      canvas.height = h;
      
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        100,
        w / h,
        0.2, 1000
      );
      
      camera.position.set(-3, 2, 0);
      camera.lookAt(new THREE.Vector3(0,0,0));
      

      const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true
      });
      renderer.setSize(w, h);
      
      
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);


      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
      directionalLight.position.set(-150, 50, -150);


      if(setting.shadow) {
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // ソフトな影
    
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = setting.shadowMapSize;
        directionalLight.shadow.mapSize.height = setting.shadowMapSize;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -300;
        directionalLight.shadow.camera.right = 300;
        directionalLight.shadow.camera.top = 300;
        directionalLight.shadow.camera.bottom = -300;
      }

      scene.add(directionalLight);
      
      /*const axesHelper = new THREE.AxesHelper(1000);
      scene.add(axesHelper);*/
      
      let stage = 0;
      
      // カメラ制御用パラメータ
      let radius = 5;
      let radiusMax = 10;
      let radiusMin = 1.5;
      let yaw = -Math.PI/2; // 水平角
      let pitch = -0.3; // 垂直角
      
      let preTime = null;
      let deltaTime = 0;
      let ignoreTouchList = [];
      
      /*
        [0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0],
      */

      const Data = [ // 新しい種類のブロックを作る時の主な変更するべき関数
        //makeCube, check, isFall, rollValid
        {
          start: {x: 0, y: 1, z: 6},
          timeLimit: null,
          setting: {
            radius: 5,
            yaw: 0,
            pitch: -0.5,
          },
          // stage---0:空,1:普通のブロック(灰色),2:死のブロック(赤色),3:ツルツルのブロック(水色),4:Goal
          stage: [ // data[stage数].stage[yInd][zInd][xInd]で取得！
            [
              [0,0,0,0,3,0,0,0,0,0,0,0,0],
              [1,1,1,0,1,0,1,1,1,0,0,0,0],
              [1,0,0,0,1,1,3,0,0,0,0,0,0],
              [1,0,0,0,0,0,0,0,0,0,0,0,0],
              [1,2,0,0,0,0,0,0,0,0,0,0,0],
              [1,0,0,0,0,0,0,1,0,0,0,0,0],
              [1,0,0,0,0,0,1,1,0,0,0,0,0],
            ],
            [
              [1,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,2,0,0,0,1,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,1,0,0,0,0,0,0],
            ],
            [
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,1,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,4,1,1,0,0,0,0,0,0,0,0],
            ],
            [
              [1,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,1,0,0,0,0],
              [0,0,0,0,0,0,0,0,1,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
            ],
            [
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,1,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
            ],
            [
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,1,1,0,0,0,0],
              [0,0,0,0,0,0,0,3,0,0,0,0,0],
              [0,0,0,0,0,0,0,3,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
            ]
          ]
        },
        {
          start: {x: 0, y: 3, z: 0},
          timeLimit: null,
          needKeys: 1,
          setting: {
            radius: 5,
            yaw: 0,
            pitch: -0.5,
          },
          // stage---0:空,1:普通のブロック(灰色),2:死のブロック(赤色),3:ツルツルのブロック(水色),4:Goal
          stage: [ // data[stage数].stage[yInd][zInd][xInd]で取得！
            [
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,2,1,0,0,1,0,0,0,0,0],
              [0,0,0,0,0,1,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
            ],
            [
              [0,2,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,5,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
            ],
            [
              [4,0,1,0,0,1,0,0,0,0,0,0,0],
              [0,1,0,0,1,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,2,1,0,0,0,0,0,0],
              [0,0,0,0,0,0,3,0,0,0,0,0,0],
              [0,0,0,0,0,1,1,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
            ],
            [
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,3,2,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
            ],
            [
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,3,0,1,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
            ],
            [
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,2,0,0,0,0,0],
              [0,0,0,0,0,3,1,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
            ],
            [
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0,0,0,0],
            ]
          ]
        },
        {
          start: {x: 0, y: 1, z: 0},
          timeLimit: null,
          setting: {
            radius: 5,
            yaw: 0,
            pitch: -0.5,
          },
          stage: [
            [
              [1,1,3,1,1,1,0,0,1,0],
              [0,0,1,0,0,0,0,0,0,0],
              [0,0,0,0,1,0,0,0,1,4]
            ],
            [
              [0,0,0,2,0,1,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,3,0,1,0,0]
            ],
            [
              [0,0,0,0,0,1,0,0,0,0],
              [0,0,0,0,0,1,0,0,0,0],
              [0,0,0,0,0,3,0,0,0,0]
            ],
            [
              [0,0,0,0,0,2,1,3,0,0],
              [0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0,0]
            ]
          ]
        },
      ];
      
      let data = structuredClone(Data);
      
      const g = 6;
      
      const me = {
        pos: {x: 0, y: 0, z: 0},
        rotation: {x: 0, y: 0, z: 0},
        model: null,
        moveDirection: new THREE.Vector3(0,0,0),
        fallStopY: 0,
        fallStopTime: 0,
        fallStartPos: {x: 0, y: 0, z: 0},
        rolling: false,
        falling: false,
        
        deadCount: {all: 0, stage: 0},
        moveCount: {all: 0, stage: 0, lately: 0},
        timeCount: {all: 0, stage: 0, lately: 0},
        
        keys: {data: [], count: 0},
        goals: [],
      }

      function nextStage() {
        stage += 1;
        me.deadCount.stage = 0;
        me.moveCount.stage = 0;
        me.timeCount.stage = 0;
        callStage();
      }
      
      function getCubeKind(pos) {
        const stract = data[stage].stage;
        const x = pos.x;
        const y = pos.y;
        const z = pos.z;
        if (
            y < 0 || y >= stract.length ||
            z < 0 || z >= stract[y].length ||
            x < 0 || x >= stract[y][z].length
          ) {
        return 0; // 範囲外は「空」とみなす
        }
        return stract[y][z][x];
      }
      
      function checkSurrounding(center) {
        let moveDir = [];
        const dirs = [
          [ 1, 0, 0],
          [-1, 0, 0],
          [ 0, 1, 0],
          [ 0,-1, 0],
          [ 0, 0, 1],
          [ 0, 0,-1]
        ];
        
        for(let k = 0; k < dirs.length; k++) {
          const dir = dirs[k];
          const pos = center;
          const kind = getCubeKind({x: pos.x+dir[0], y: pos.y+dir[1], z: pos.z+dir[2]});
          if(kind == 0) continue;
          moveDir.push({x: dir[0], y: dir[1], z: dir[2], kind: kind});
        }
        
        return moveDir;
      }
      
      function makeOneCube(color, pos, size=1) {
        let geometry = new THREE.BoxGeometry(size, size, size);// 立方体
        let material = new THREE.MeshLambertMaterial({color: color});
        //let material = new THREE.MeshBasicMaterial({color: 0xcccccc});
        const cube = new THREE.Mesh(geometry, material);// それらをまとめて3Dオブジェクトにします
        cube.position.set(pos.x, pos.y, pos.z);
        if(setting.shadow) {
          cube.castShadow = true;
          cube.receiveShadow = true;
        }
        scene.add(cube);
        return cube;
      }
      
      function makeCube(kind, pos) {
        if(kind == -1) { // me
          return makeOneCube(0xffbbbb, pos);
        } else if(kind == 0) {
          return;
        } else if(kind == 1) {
          return makeOneCube(0xcccccc, pos);
        } else if(kind == 2) {
          return makeOneCube(0xff0000, pos);
        } else if(kind == 3) {
          return makeOneCube(0x8888dd, pos);
        } else if(kind == 4) {
          if(data[stage].needKeys >= 1) {
            const cube4 = makeOneCube(0x5555000, pos);
            me.goals.push(cube4);
            return cube4;
          } else {
            return makeOneCube(0xcccc00, pos);
          }
        } else if(kind == 5) {
          const cube5 = makeOneCube(0xff8888, pos, 0.5);
          me.keys.data.push([cube5, pos]);
          return cube5;
        }
      }
      
      
      function createStageAndMe(stage) {
        const startPos = data[stage].start;
        me.model = makeCube(-1, {x: startPos.x, y: startPos.y, z: startPos.z});
        
        const stract = data[stage].stage;
        
        for(let yInd = 0; yInd < stract.length; yInd++) {
          for(let zInd = 0; zInd < stract[yInd].length; zInd++) {
            for(let xInd = 0; xInd < stract[yInd][zInd].length; xInd++){
              makeCube(stract[yInd][zInd][xInd], {x: xInd, y: yInd, z: zInd});
            }
          }
        }
        //makeCube(1, {x: 0, y: 0, z: 0})
      }
      
      function init() {
        me.deadCount.all = 0;
        me.moveCount.all = 0;
        me.timeCount.all = 0;
        me.deadCount.stage = 0;
        me.moveCount.stage = 0;
        me.timeCount.stage = 0;
        
        me.keys = {data: [], count: 0};
        callStage();
      }
      
      
      function callStage() {
        data = structuredClone(Data);
        // シーンから既存のオブジェクトを削除
        for (let i = scene.children.length - 1; i >= 0; i--) {
          const obj = scene.children[i];
          if (!(obj.isLight || obj.isCamera)) {
            scene.remove(obj);
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
              if (Array.isArray(obj.material)) {
                obj.material.forEach(m => m.dispose());
              } else {
                obj.material.dispose();
              }
            }
          }
        }

        me.rolling = false;
        me.falling = false;
        me.rotation = {x:0, y:0, z:0};
        me.pos = structuredClone(data[stage].start);
        me.model = null;
        
        me.deadCount.lately = 0;
        me.moveCount.lately = 0;
        me.timeCount.lately = 0;
        
        me.keys = {data: [], count: 0};
        me.goals = [];
        
        preTime = null;
        
        if(Object.keys(data[stage]).includes("setting")) {
          radius = data[stage].setting.radius ?? 5;
          yaw = data[stage].setting.yaw ?? Math.PI/2; // 水平角
          pitch = data[stage].setting.pitch ?? -0.5; // 垂直角
        } else {
          radius = 5;
          yaw = Math.PI/2;
          pitch = -0.5;
        }

        createStageAndMe(stage);
      }

      
      init();
      
      let rollStartPos = {x: 0, y: 0, z: 0};
      let rollStartTime = 0;
      let rollDire = ["x", 1]; // どの方向に転がるか(1 or -1)
      let rollDireAsp = ["y", 1]; // どの方向に盛り上がりながら移動するか(1 or -1)
      let rollTime = 0.4;
      
      function vectorSum(a, b) {
        return {x: a.x+b.x, y: a.y+b.y, z: a.z+b.z};
      }
      
      function goal() {
        if(data[stage].needKeys > me.keys.count) return;
        me.goal = true;
        me.goalStart = Date.now();
        me.goalParticles = createGoalParticles(me.model.position.clone());
      }
      
      function dead() {
        me.dead = true;
        me.deadStart = Date.now();
        me.deadCount.all += 1;
        me.deadCount.stage += 1;
      }

      
      function check() {
        if(me.rolling || me.falling) return;
        
        if(getCubeKind(me.pos) == 5) {
          me.keys.count += 1;
          if(me.keys.count >= data[stage].needKeys) {
            for(let k of me.goals) k.material.color.set(0xcccc00);
          }
          for(let k = 0; k < me.keys.data.length; k++) {
            const model = me.keys.data[k][0];
            const posK = me.keys.data[k][1];

            if(me.pos.x == posK.x && me.pos.y == posK.y && me.pos.z == posK.z) {
              console.log(posK)
              // シーンから削除
              if(model.parent) {
                model.parent.remove(model);
              }

              // メモリ解放（必要に応じて）
              model.traverse(obj => {
                if(obj.isMesh) {
                  if(obj.geometry) obj.geometry.dispose();
                  if(obj.material) {
                    if(Array.isArray(obj.material)) {
                      obj.material.forEach(m => m.dispose());
                    } else {
                      obj.material.dispose();
                    }
                  }
                }
              });

              // 配列から削除
              me.keys.data.splice(k, 1);
              data[stage].stage[posK.y][posK.z][posK.x] = 0;
              k--;
            }
          }
        }

        
        const surrounding = checkSurrounding(me.pos);
        
        for(let k of surrounding) {
          //console.log(k)
          if(k.kind == 2) {
            dead();
            return;
          } else if(k.kind == 4) {
            goal();
            return;
          }
        }
      }
      
      function isFall() {
        //console.log("@")
        if(me.falling || me.rolling) return;
        
        if(getCubeKind({x: me.pos.x, y: me.pos.y-1, z: me.pos.z}) != 0) return;
        
        const surrounding = checkSurrounding(me.pos);
        
        for(let k = 0; k < surrounding.length; k++) {
          if(surrounding[k].kind != 0 && surrounding[k].kind != 3 && surrounding[k].kind != 5) return; 
        }
        
        me.falling = true;
        me.fallStartPos = structuredClone(me.pos);
        me.fallStopY = null;
        
        me.fallStopTime = Date.now() + 1000 * Math.sqrt(2*(me.fallStartPos.y-setting.deadLineY)/g);
        me.fallStopY = null;
        
        for(let k = me.fallStartPos.y-2; k >= 0; k--) {
          if(getCubeKind({x: me.fallStartPos.x, y: k, z: me.fallStartPos.z}) != 0) {
            me.fallStopY = k+1;
            me.fallStopTime = Date.now() + 1000 * Math.sqrt(2*(me.fallStartPos.y-k-1)/g);
            break;
          }
        }
        
        me.fallStartTime = Date.now();
        return;
      }
      

      function calcFalling() {
        if(!me.falling) return;
        if(me.fallStopTime <= Date.now()) {
          if(me.fallStopY === null) {
            dead();
            return;
          } else {
            me.model.position.y = me.fallStopY;
            me.pos.y = me.fallStopY;
            me.falling = false;
            return;
          }
        }
        
        me.model.position.y = me.fallStartPos.y - g/2*((Date.now()-me.fallStartTime)/1000)**2;
        
        camera.lookAt(me.model.position);
      }
      
      function rollValid(moveDire, moveDireAsp) {
        // 移動後にブロックがなくてもvalidにしている！
        // (rollUpdateで、移動後のcheckSurrounfing.lengthが0なら追加でπさせるため(確実にブロックある))
        const zeroVector = {x: 0, y: 0, z: 0};
        const dire = structuredClone(zeroVector);
        const direAsp = structuredClone(zeroVector);
        
        dire[moveDire[0]] = moveDire[1];
        direAsp[moveDireAsp[0]] = moveDireAsp[1];
        
        const stract = data[stage].stage;
        
        let k0 = vectorSum(me.pos, direAsp);
        let k1 = vectorSum(k0, dire);
        let k2 = vectorSum(me.pos, dire);
        let d0 = vectorSum(me.pos, {x: -direAsp.x, y: -direAsp.y, z: -direAsp.z});
        
        if(getCubeKind(k2) != 0 && getCubeKind(k2) != 5) return false;
        if(getCubeKind(d0) == 0 && getCubeKind(d0) != 5) return false;
        if((getCubeKind(k0) != 0 || getCubeKind(k1) != 0) && getCubeKind(k1) != 5) return false;
        
        return true;
      }
      
      function rollCube(dire, direAsp, tf=false) {
        if((me.rolling || me.falling) && !tf) return;
        
        rollStartTime = Date.now();
        rollStartPos = structuredClone(me.pos);
        rollDire = dire;
        rollDireAsp = direAsp;
        
        if(!tf) {
          me.moveCount.all += 1;
          me.moveCount.stage += 1;
          me.moveCount.lately += 1;
        }
        
        me.rolling = true;
      }
      
      function updateRoll() {
        if(!me.rolling || me.falling) return;
        
        if(Date.now() - rollStartTime > rollTime * 1000) {
          me.rotation = {x: 0, y: 0, z: 0};
          if(rollDire[0] == "x") {
            me.pos.x = rollStartPos.x + rollDire[1];
            me.pos.y = rollStartPos.y;
            me.pos.z = rollStartPos.z;
          } else if(rollDire[0] == "y") {
            me.pos.y = rollStartPos.y + rollDire[1];
            me.pos.x = rollStartPos.x;
            me.pos.z = rollStartPos.z;
          } else if(rollDire[0] == "z") {
            me.pos.z = rollStartPos.z + rollDire[1];
            me.pos.x = rollStartPos.x;
            me.pos.y = rollStartPos.y;
          }
          const surrounding = checkSurrounding(me.pos);
          if(surrounding.length == 0 || surrounding.every(v => v.kind === 5)) {
            rollCube([rollDireAsp[0], -rollDireAsp[1]], rollDire, true);
          } else {
            me.rolling = false;
          }
          return;
        }
        
        let rollTheta = 3*Math.PI/4 - ((Date.now()-rollStartTime)/1000)/rollTime * Math.PI/2;
        if(rollDire[0] == "x") {
          me.pos.x = rollStartPos.x + rollDire[1] * (0.5 + Math.cos(rollTheta)/Math.sqrt(2));
          if(rollDireAsp[0] == "y") {
            me.pos.y = rollStartPos.y + rollDireAsp[1] * (-0.5 + Math.sin(rollTheta)/Math.sqrt(2));
          } else if(rollDireAsp[0] == "z") {
            me.pos.z = rollStartPos.z + rollDireAsp[1] * (-0.5 + Math.sin(rollTheta)/Math.sqrt(2));
          }
        } else if(rollDire[0] == "y") {
          me.pos.y = rollStartPos.y + rollDire[1] * (0.5 + Math.cos(rollTheta)/Math.sqrt(2));
          if(rollDireAsp[0] == "x") {
            me.pos.x = rollStartPos.x + rollDireAsp[1] * (-0.5 + Math.sin(rollTheta)/Math.sqrt(2));
          } else if(rollDireAsp[0] == "z") {
            me.pos.z = rollStartPos.z + rollDireAsp[1] * (-0.5 + Math.sin(rollTheta)/Math.sqrt(2));
          }
        } else if(rollDire[0] == "z") {
          me.pos.z = rollStartPos.z + rollDire[1] * (0.5 + Math.cos(rollTheta)/Math.sqrt(2));
          if(rollDireAsp[0] == "x") {
            me.pos.x = rollStartPos.x + rollDireAsp[1] * (-0.5 + Math.sin(rollTheta)/Math.sqrt(2));
          } else if(rollDireAsp[0] == "y") {
            me.pos.y = rollStartPos.y + rollDireAsp[1] * (-0.5 + Math.sin(rollTheta)/Math.sqrt(2));
          }
        }
        
        // 0°startに変換
        rollTheta = 3*Math.PI/4 - rollTheta;
        
        if(rollDire[0] == "x") {
          if(rollDireAsp[0] == "z") {
            me.rotation.y = rollDire[1]*rollDireAsp[1] * rollTheta;
          } else if(rollDireAsp[0] == "y") {
            me.rotation.z = -rollDire[1]*rollDireAsp[1] * rollTheta;
          }
        } else if(rollDire[0] == "y") {
          if(rollDireAsp[0] == "z") {
            me.rotation.x = -rollDire[1]*rollDireAsp[1] * rollTheta;
          } else if(rollDireAsp[0] == "x") {
            me.rotation.z = rollDire[1]*rollDireAsp[1] * rollTheta;
          } 
        } else if(rollDire[0] == "z") {
          if(rollDireAsp[0] == "x") {
            me.rotation.y = -rollDire[1]*rollDireAsp[1] * rollTheta;
          } else if(rollDireAsp[0] == "y") {
            me.rotation.x = rollDire[1]*rollDireAsp[1] * rollTheta;
          }
        }
      }

      
      

      function updateCamera() {
        if(me.falling) return;
        const x = me.pos.x - radius * Math.cos(yaw) * Math.cos(pitch);
        const y = me.pos.y - radius * Math.sin(pitch);
        const z = me.pos.z + radius * Math.sin(yaw) * Math.cos(pitch);
        camera.position.set(x, y, z);
        camera.lookAt(new THREE.Vector3(me.pos.x, me.pos.y, me.pos.z));
      }
      
      function updateMe() {
        if(me.falling) return;
        me.model.position.set(me.pos.x, me.pos.y, me.pos.z);
        me.model.rotation.set(me.rotation.x, me.rotation.y, me.rotation.z);
      }
      
      let isDragging = false;
      let lastX = 0, lastY = 0;

      window.addEventListener("mousedown", e => {
        if(me.falling || me.rolling || (header && header.contains(e.target))) {
          ignoreTouchList.push("mouse");
        }
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
      });
      window.addEventListener("mouseup", e => {
        if(ignoreTouchList.includes("mouse")) {
          ignoreTouchList = [];
          return;
        }
        
        isDragging = false;
      });
      window.addEventListener("mousemove", e => {
        if(ignoreTouchList.includes("mouse")) return;
        
        if (!isDragging) return;
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX;
        lastY = e.clientY;

        yaw -= dx * 0.01 * setting.cameraSensitivity.yaw;
        pitch -= dy * 0.01 * setting.cameraSensitivity.pitch;
        pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, pitch));
      });
      window.addEventListener("wheel", e => {
        if(me.rolling || me.falling) return;
        radius += e.deltaY * 0.01;
        radius = Math.max(radiusMin, Math.min(radiusMax, radius));
      });
      window.addEventListener("keydown", e => {
        if(me.rolling || me.falling) return;
        if (["ArrowUp","w"].includes(e.key)) me.moveDirection.set(0,0,-1);
        if (["ArrowDown","s"].includes(e.key)) me.moveDirection.set(0,0, 1);
        if (["ArrowLeft","a"].includes(e.key)) me.moveDirection.set(-1,0,0);
        if (["ArrowRight","d"].includes(e.key)) me.moveDirection.set( 1,0,0);
      });
      window.addEventListener("keyup", e => {
        me.moveDirection.set(0,0,0);
      });


      // =================== タッチ ===================
      let touchStartDist = 0;
      let touchMode = null; // "camera" or "move" or "zoom"
      let swipeStart = null;

      window.addEventListener("touchstart", e => {
        if(me.falling || me.rolling || (header && header.contains(e.target))) {
          for (let touch of e.changedTouches) {
            ignoreTouchList.push(touch.identifier);
            continue;
          }
        }
        if (e.touches.length === 1) {
          const x = e.touches[0].clientX;
          const y = e.touches[0].clientY;
          if (x < window.innerWidth / 2) {
            // 左側 = カメラ
            touchMode = "camera";
            isDragging = true;
            lastX = x;
            lastY = y;
          } else {
            // 右側 = 移動
            touchMode = "move";
            swipeStart = {x, y};
          }
        } else if (e.touches.length === 2) {
          // ズーム
          touchMode = "zoom";
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          touchStartDist = Math.sqrt(dx*dx + dy*dy);
        }
      });
      window.addEventListener("touchmove", e => {
        for(let touch of e.changedTouches) {
          if(ignoreTouchList.includes(touch.identifier)) return;
        }
        if (touchMode === "camera" && e.touches.length === 1 && isDragging) {
          const dx = e.touches[0].clientX - lastX;
          const dy = e.touches[0].clientY - lastY;
          lastX = e.touches[0].clientX;
          lastY = e.touches[0].clientY;

          yaw -= dx * 0.01 * setting.cameraSensitivity.yaw;
          pitch -= dy * 0.01 * setting.cameraSensitivity.pitch;
          pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, pitch));
        } else if (touchMode === "zoom" && e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          const dist = Math.sqrt(dx*dx + dy*dy);
          const delta = dist - touchStartDist;
          radius -= delta * 0.01;
          radius = Math.max(radiusMin, Math.min(radiusMax, radius));
          touchStartDist = dist;
        }
      });
      window.addEventListener("touchend", e => {
        let ret = false;
        for(let touch of e.changedTouches) {
          if(ignoreTouchList.includes(touch.identifier)) {
            ignoreTouchList = ignoreTouchList.filter(k => k != touch.identifier);
            ret = true;
          }
        }
        if(ret) return;
        if (touchMode === "move" && swipeStart) {
          const touch = e.changedTouches[0];
          const dx = touch.clientX - swipeStart.x;
          const dy = touch.clientY - swipeStart.y;

          const L = Math.sqrt(dx*dx + dy*dy);
          if (L > 30) {
            const ndx = dx / L;
            const ndy = dy / L;

            
            
            // カメラのforward, right, upを計算
            const forward = new THREE.Vector3(
              Math.cos(yaw) * Math.cos(pitch),
              Math.sin(pitch),
              - Math.sin(yaw) * Math.cos(pitch)
            ).normalize();
      
            const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();
            const up = new THREE.Vector3().crossVectors(right, forward).normalize();
      
            // スワイプ方向を変換（up/right基準）
            const dir = new THREE.Vector3()
              .addScaledVector(up, -ndy)
              .addScaledVector(right, ndx)
              .normalize();

            // 軸を選択
            let axis = "x";
            let value = dir.x;
            if (Math.abs(dir.y) > Math.abs(value)) {
              axis = "y";
              value = dir.y;
            }
            if (Math.abs(dir.z) > Math.abs(value)) {
              axis = "z";
              value = dir.z;
            }
            
            let moveDire = [axis, value >= 0 ? 1 : -1];
            

            const camDir = new THREE.Vector3()
              .subVectors(camera.position, me.model.position)
              .normalize();

            let camAxis = "x";
            let camValue = camDir.x;
            if (Math.abs(camDir.y) > Math.abs(camValue)) {
              camAxis = "y"; camValue = camDir.y;
            }
            if (Math.abs(camDir.z) > Math.abs(camValue)) {
              camAxis = "z"; camValue = camDir.z;
            }

            let moveAspDire = [camAxis, camValue >= 0 ? 1 : -1];
            
            const stract = data[stage].stage;
            
            if(!rollValid(moveDire, moveAspDire)) {
              // 前に進む向きに変える
              const preMoveDire = moveDire;
              moveDire = [moveAspDire[0], -moveAspDire[1]];
              moveAspDire = preMoveDire;
              
              if(!rollValid(moveDire, moveAspDire)) return;
            }
            
            
            
            rollCube(moveDire, moveAspDire);
          }
        }

        if (e.touches.length === 0) {
          isDragging = false;
          touchMode = null;
          swipeStart = null;
        }
      });
      document.getElementById("retry").addEventListener("click", (e) => {
        dead();
        e.preventDefault();
      });


      
      window.addEventListener('resize', () => {
        w = innerWidth;
        h = innerHeight - headerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      });
      
      
      
      // パーティクル生成関数
      function createGoalParticles(position) {
        const count = 100; // 粒の数
        const geometry = new THREE.BufferGeometry();
        const positions = [];

        for (let i = 0; i < count; i++) {
          positions.push(
            position.x,
            position.y,
            position.z
          );
        }

        geometry.setAttribute(
          'position',
          new THREE.Float32BufferAttribute(positions, 3)
        );

        const material = new THREE.PointsMaterial({
          color: 0xffff00,
          size: 0.1,
          transparent: true,
          opacity: 1
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);

        return { points, geometry, material };
      }

      
      
      function animate() {
        requestAnimationFrame(animate);
        
        /*me.timeCount.all = (Date.now() - me.timeStart.all)/1000;
        if(!me.goal) me.timeCount.stage = (Date.now() - me.timeStart.stage)/1000;
        if(!me.dead && !me.goal) me.timeCount.lately = (Date.now() - me.timeStart.lately)/1000;*/
        
        
        
        // もし死亡中ならアニメーション
        if (me.dead) {
          const elapsed = Date.now() - me.deadStart;
          const t = Math.min(elapsed / 2000, 1); // 0 → 1 に進む（2秒間）

          // グニャグニャ係数（sin波で揺らす）
          const wobbleX = Math.sin(elapsed * 0.02) * 0.2 * (1 - t);
          const wobbleY = Math.sin(elapsed * 0.025 + 1) * 0.2 * (1 - t);
          const wobbleZ = Math.sin(elapsed * 0.03 + 2) * 0.2 * (1 - t);

          // 基本的な縮小率
          const baseScale = 1 - t;

          // 軸ごとに揺れを加えたスケール
          me.model.scale.set(
            baseScale + wobbleX,
            baseScale + wobbleY,
            baseScale + wobbleZ
          );

          // 透明度も減らす
          if (me.model.material && "opacity" in me.model.material) {
            me.model.material.transparent = true;
            me.model.material.opacity = 1 - t;
          }

          if (t >= 1) {
            me.dead = false;
            callStage();
          }

          renderer.render(scene, camera);
          return;
        }
        if (me.goal) {
          const elapsed = Date.now() - me.goalStart;
          const t = Math.min(elapsed / 2500, 1); // 2秒で0→1

          // 初回のみ生成
          if (!me.particles) {
            const particleCount = 100;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
              // 位置はキャラの周り
              positions[i * 3] = (Math.random() - 0.5) * 0.5;
              positions[i * 3 + 1] = (Math.random() - 0.5) * 0.5;
              positions[i * 3 + 2] = (Math.random() - 0.5) * 0.5;

              // 上方向へ舞う
              velocities[i * 3] = (Math.random() - 0.5) * 0.01;
              velocities[i * 3 + 1] = Math.random() * 0.03 + 0.01;
              velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.01;
            }

            geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute("velocity", new THREE.BufferAttribute(velocities, 3));

            const material = new THREE.PointsMaterial({
              color: 0xffffaa,
              size: 0.05,
              transparent: true,
              opacity: 1,
              depthWrite: false,
            });

            me.particles = new THREE.Points(geometry, material);

            // モデルに付けずに直接シーンへ（干渉防止）
            scene.add(me.particles);

            // 位置をキャラの現在地に合わせる
            me.particles.position.copy(me.model.position);
          }

           // パーティクル更新
          const positions = me.particles.geometry.attributes.position.array;
          const velocities = me.particles.geometry.attributes.velocity.array;

          for (let i = 0; i < positions.length; i += 3) {
            positions[i] += velocities[i];
            positions[i + 1] += velocities[i + 1];
            positions[i + 2] += velocities[i + 2];
          }
          me.particles.geometry.attributes.position.needsUpdate = true;

          // 徐々に消える
          me.particles.material.opacity = 1-t**3;

          if (t >= 1) {
            // パーティクルを削除
            scene.remove(me.particles);
            me.particles.geometry.dispose();
            me.particles.material.dispose();
            me.particles = null;

            me.goal = false;

            nextStage();
          }
          renderer.render(scene, camera);
          return;
        }



        
        if(!preTime) {
          me.startTime = Date.now();
          preTime = Date.now();
        }
        deltaTime = Date.now() - preTime;
        preTime = Date.now();
        
        if(!me.dead && !me.goal) {
          me.timeCount.all += deltaTime;
          me.timeCount.stage += deltaTime;
          me.timeCount.lately += deltaTime;
        }
        textDiv.innerHTML = `${data[stage].needKeys >= 1 ? (me.keys.count >= data[stage].needKeys ? '<span style="color: #66dd66;">' : '<span style="color: #dd6666;">') : ''}Keys : ${me.keys.count} / ${data[stage].needKeys ?? 0}${data[stage].needKeys >= 1 ? '</span>' : ''}<br>Stage : ${stage}<br>
Time : ${(me.timeCount.lately/1000).toFixed(1)}秒 / ${(me.timeCount.stage/1000).toFixed(1)}秒<br>
Move : ${me.moveCount.lately}回 / ${me.moveCount.stage}回<br>
Fail : ${me.deadCount.stage}回`;
        
        updateRoll();
        updateMe();
        calcFalling();
        isFall();
        check();
        updateCamera();
        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html>

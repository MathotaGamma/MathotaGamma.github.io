<!DOCTYPE html>
<html lang="ja">
  <head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-8LX6SFM3DB"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() { dataLayer.push(arguments); }
      gtag('js', new Date());

      gtag('config', 'G-8LX6SFM3DB');
    </script>
    <meta charset="UTF-8" />
    <meta name="keywords" content="Blog,NeoTopazm">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>NeoTopazm</title>
    <style>
      html, body {
        margin: 0; padding: 0;
        width: 100%; height: 100%;
        background: black;
        color: white;
        font-family: sans-serif;
        -webkit-touch-callout:none;
        -webkit-user-select:none;
        overflow:hidden;
      }
      body {
        overflow-y: scroll;
        position: relative;
      }
      header {
        position: fixed;
        top: 0;
        right: 0;
        width: 100%;
        height: 50px;
        background: rgba(0,0,0,0.6);
        color: white;
        display: flex;
        justify-content: flex-end;
        align-items: center;
        padding: 0 20px;
        gap: 20px;
        z-index: 500;
        font-weight: bold;
      }
      #title {
        position: fixed;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        font-size: 48px;
        font-weight: bold;
        color: #ffb933;
        font-family: sans-serif;
        pointer-events: none;
        display: flex;
        gap: 5px;
        z-index: 10;
      }
      .title-char {
        opacity: 1;
        animation-name: flameFlicker;
        animation-duration: 1.5s;
        animation-iteration-count: infinite;
        animation-timing-function: ease-in-out;
        animation-direction: alternate;
        filter: drop-shadow(0 0 12px #ffb933) drop-shadow(0 0 20px #ff6b00);
        display: inline-block;
        vertical-align: middle;
        line-height: 1;
        transform: translateY(-2px);
      }
      @keyframes flameFlicker {
        0% {
          filter: drop-shadow(0 0 15px #ffd633) drop-shadow(0 0 30px #ff7f00);
          transform: translateY(0) scale(1);
          color: #ffcc33;
          text-shadow: 0 0 10px #ffcc33, 0 0 20px #ff6600;
        }
        50% {
          filter: drop-shadow(0 0 25px #fff85c) drop-shadow(0 0 40px #ff8000);
          transform: translateY(-3px) scale(1.05);
          color: #fff85c;
          text-shadow: 0 0 15px #fff85c, 0 0 30px #ff9900;
        }
        100% {
          filter: drop-shadow(0 0 15px #ffd633) drop-shadow(0 0 30px #ff7f00);
          transform: translateY(0) scale(1);
          color: #ffcc33;
          text-shadow: 0 0 10px #ffcc33, 0 0 20px #ff6600;
        }
      }
      canvas {
        display: block;
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        pointer-events: none;
        z-index: 1;
      }
      main {
        margin-top: 60px;
        padding: 20px;
        z-index: 1;
        position: relative;
        overflow: scroll;
      }
      .link {
        color: white;
        text-decoration: underline;
        text-decoration-style: wavy;
        text-decoration-color: white;
      }
      .link:hover {
        text-decoration-style: double;
        text-decoration-color: red;
      }
    </style>
    <meta name="google-site-verification" content="cZm1sI9kSs1pR93g9D6fHY9t2Nw1nGDDhe0SPMMtNpE" />
  </head>
  <body>
    <header>
      <div><a href="./contact" class="link">ContactUs</a></div>
      <div style="z-index: 49;"><a href="./Blog/" class="link">Blog</a></div>
      <div><a href="./Tools/" class="link">Tools</a></div>
      <div><a class="link" href="./Activity/">Activity</a></div>
      <div><a class="link" href="./Info/">Info</a></div>
    </header>
    <div id="title"></div>
    <canvas id="canvas"></canvas>
    <main>
      <p>
        このブログでは、数学や物理などの一見難しそうな話題を、
        専門的な前提知識がなくても楽しめるように解説していきます。
      </p>
      <p>
        難解な概念も、わかりやすく・美しく・直感的に伝えることを目指しています。
        数式や理論の背後にある「アイデアの美しさ」に触れていただけたら嬉しいです。
      </p>
      <p style="margin-bottom: 1000px;"></p>
    </main>
    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';

      const canvas2d = document.getElementById('canvas');
      const ctx = canvas2d.getContext('2d');
      let w, h;

      function resize() {
        w = canvas2d.width = window.innerWidth;
        h = canvas2d.height = window.innerHeight;
      }
      window.addEventListener('resize', resize);
      resize();

      const CUBE_NUM = 75;

      // three.js setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, w / h, 1, 2000);
      camera.position.set(0, 0, 300);

      const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize(w, h);
      renderer.setClearColor(0x000000, 0);
      renderer.domElement.style.position = 'fixed';
      renderer.domElement.style.top = '0';
      renderer.domElement.style.left = '0';
      renderer.domElement.style.width = '100%';
      renderer.domElement.style.height = '100%';
      renderer.domElement.style.pointerEvents = 'none';
      renderer.domElement.style.zIndex = '0';
      document.body.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(1, 1, 1);
      scene.add(dirLight);

      const cubes = [];
      const velocities = [];
      const CUBE_SIZE = 25;
      let BOUND_X, BOUND_Y, BOUND_Z;

      function getRandomColor() { return new THREE.Color(Math.random(), Math.random(), Math.random()); }

      function updateBounds() {
        BOUND_X = window.innerWidth / 4;
        BOUND_Y = window.innerHeight / 4;
        BOUND_Z = 100;
      }
      updateBounds();

      for (let i = 0; i < CUBE_NUM; i++) {
        const geo = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
        const mat = new THREE.MeshStandardMaterial({ color: getRandomColor() });
        const cube = new THREE.Mesh(geo, mat);
        cube.position.set(
          (Math.random() - 0.5) * BOUND_X * 2,
          (Math.random() - 0.5) * BOUND_Y * 2,
          (Math.random() - 0.5) * BOUND_Z * 2
        );
        scene.add(cube);
        cubes.push(cube);
        velocities.push(new THREE.Vector3(
          (Math.random() - 0.5) * 0.3,
          (Math.random() - 0.5) * 0.3,
          (Math.random() - 0.5) * 0.3
        ));
      }

      window.addEventListener('resize', () => {
        w = window.innerWidth;
        h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
        canvas2d.width = w;
        canvas2d.height = h;
        updateBounds();
      });

      function updateCubes() {
        for (let i = 0; i < cubes.length; i++) {
          const cube = cubes[i];
          const v = velocities[i];
          cube.position.add(v);
          ['x','y','z'].forEach(axis => {
            const limit = axis==='x'?BOUND_X:(axis==='y'?BOUND_Y:BOUND_Z);
            if(cube.position[axis]<-limit){cube.position[axis]=-limit;v[axis]=-v[axis];}
            else if(cube.position[axis]>limit){cube.position[axis]=limit;v[axis]=-v[axis];}
          });
          v.multiplyScalar(0.995);
        }

        const RESTITUTION=0.8;
        const radius=CUBE_SIZE*Math.sqrt(3)/2;
        for(let i=0;i<cubes.length;i++){
          for(let j=i+1;j<cubes.length;j++){
            const c1=cubes[i],c2=cubes[j];
            const dist=c1.position.distanceTo(c2.position);
            if(dist<radius*2){
              const v1=velocities[i],v2=velocities[j];
              const normal=new THREE.Vector3().subVectors(c2.position,c1.position).normalize();
              const relativeVelocity=new THREE.Vector3().subVectors(v2,v1);
              const velocityAlongNormal=relativeVelocity.dot(normal);
              if(velocityAlongNormal>0) continue;
              const impulse=(-(1+RESTITUTION)*velocityAlongNormal)/2;
              const impulseVector=normal.clone().multiplyScalar(impulse);
              v1.sub(impulseVector);
              v2.add(impulseVector);
              const overlap=radius*2-dist;
              const correction=normal.clone().multiplyScalar(overlap/2);
              c1.position.add(correction.clone().negate());
              c2.position.add(correction);
            }
          }
        }
      }

      function reactToTouch(clientX, clientY){
        const mouse=new THREE.Vector2((clientX/w)*2-1,-(clientY/h)*2+1);
        const raycaster=new THREE.Raycaster();
        raycaster.setFromCamera(mouse,camera);
        const intersects=raycaster.intersectObjects(cubes);
        intersects.forEach(intersect=>{
          const idx=cubes.indexOf(intersect.object);
          if(idx!==-1){
            const cube=cubes[idx];
            const v=velocities[idx];
            const point=intersect.point;
            const dir=new THREE.Vector3().subVectors(cube.position,point).normalize();
            const force=5+Math.random()*2;
            v.addScaledVector(dir,force);
          }
        });
      }

      // 触ってて楽しいエフェクト
      const effects=[];
      let currentTouch=null;

      function spawnEffect(x,y){
        const num=8+Math.floor(Math.random()*8);
        for(let i=0;i<num;i++){
          effects.push({
            x:x, y:y,
            vx:(Math.random()-0.5)*3,
            vy:(Math.random()-0.5)*3,
            size:2+Math.random()*3,
            life:5+Math.floor(Math.random()*5),
            color:`hsl(${Math.random()*360},80%,70%)`
          });
        }
      }

      window.addEventListener('mousedown',e=>{currentTouch={x:e.clientX,y:e.clientY}; reactToTouch(e.clientX,e.clientY);});
      window.addEventListener('mousemove',e=>{if(currentTouch){currentTouch.x=e.clientX;currentTouch.y=e.clientY;}});
      window.addEventListener('mouseup',()=>{currentTouch=null;});

      window.addEventListener('touchstart',e=>{const t=e.touches[0]; currentTouch={x:t.clientX,y:t.clientY}; reactToTouch(t.clientX,t.clientY);},{passive:false});
      window.addEventListener('touchmove',e=>{const t=e.touches[0]; if(currentTouch){currentTouch.x=t.clientX;currentTouch.y=t.clientY;}},{passive:false});
      window.addEventListener('touchend',()=>{currentTouch=null;});

      function handleEffects(){
        if(currentTouch){spawnEffect(currentTouch.x,currentTouch.y);}
        for(let i=effects.length-1;i>=0;i--){
          const e=effects[i];
          e.x+=e.vx; e.y+=e.vy;
          ctx.fillStyle=e.color;
          ctx.beginPath();
          ctx.arc(e.x,e.y,e.size,0,Math.PI*2);
          ctx.fill();
          e.life--;
          if(e.life<=0) effects.splice(i,1);
        }
      }

      const titleText='NeoTopazm';
      const titleElem=document.getElementById('title');
      function animateTitle(){
        titleElem.innerHTML='';
        for(let i=0;i<titleText.length;i++){
          const span=document.createElement('span');
          span.textContent=titleText[i];
          span.className='title-char';
          span.style.animationDelay=(i*0.15)+'s';
          titleElem.appendChild(span);
        }
      }
      animateTitle();

      function animate(){
        requestAnimationFrame(animate);
        ctx.clearRect(0,0,w,h);
        handleEffects();
        updateCubes();
        renderer.render(scene,camera);
      }
      animate();

    </script>
  </body>
</html>
